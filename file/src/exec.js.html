<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/exec.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/stremlenye/immutable-http.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/index.js~Http.html">Http</a></span></li>
</ul>
</div>



<div data-ice="functionWrap">
  <h2><a href="function/">Function</a></h2>
  <ul>
    
  <li data-ice="functionDoc"><span><a href="function/index.html#static-function-exec">exec</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-validate">validate</a></span></li>
</ul>
</div>






</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/exec.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">/**
 * Mixins dynamic segments replacing the `:segment_name` parts with provide
 * values
 * @param {String} url &#x2013; URL
 * @param {Object} dynamicSegments &#x2013; dynamic segments
 * @returns {String} &#x2013; URL
 */
function mixinDynamicSegmentsValues (url, dynamicSegments) {
  let aggregator = url
  for (let [key, value] of dynamicSegments.entries()) {
    aggregator = aggregator.replace(`:${key}`, value)
  }
  return aggregator
}

/**
 * Adds query params string to url
 * @param {string} url &#x2013; URL
 * @param {Array} queryParams &#x2013; query params
 * @returns {String} &#x2013; URL
 */
function addQueryParams (url, queryParams) {
  if (queryParams.size === 0)
    return url
  const chanks = [queryParams.lenght]
  for (let [key, value] of queryParams.entries()) {
    chanks.push(`${key}=${value}`)
  }
  return url + &apos;?&apos; + chanks.join(&apos;&amp;&apos;)
}

/**
 * Adds headers to xmlhttp object
 * @param {Object} xmlhttp &#x2013; XMLHttpRequest
 * @param {Object} headers &#x2013; HTTP headers key-value collection
 * @returns {Object} &#x2013; XMLHttpRequest
 */
function addHeaders (xmlhttp, headers) {
  for (let [key, value] of headers.entries()) {
    xmlhttp.setRequestHeader(key, value)
  }
  return xmlhttp
}

/**
 * Sets XMLHttpRequest response type
 * @param {Object} xmlhttp &#x2013; XMLHttpRequest
 * @param {String} responseType &#x2013; response type
 * @returns {Object} &#x2013; XMLHttpRequest
 */
function setResponseType (xmlhttp, responseType) {
  if (!responseType) return xmlhttp
  xmlhttp.responseType = responseType
  return xmlhttp
}

/**
 * Executes if xmlhttp request succeed
 * @param {fulfillCallback} fulfill &#x2013; fulfill callback
 * @param {Object} http &#x2013; HTTP object
 * @param {Object} xmlhttp &#x2013; XMLHttpRequest
 */
function onSucceed (fulfill, http, xmlhttp) {
  fulfill({
    status: xmlhttp.status,
    response: http.responseType ? xmlhttp.response : xmlhttp.responseText,
    headers: xmlhttp.getAllResponseHeaders()
  })
}

/**
 * Executes if xmlhttp request failed
 * @param {rejectCallback} reject - reject
 * @param {Object} http &#x2013; HTTP object
 * @param {Object} xmlhttp &#x2013; XMLHttpRequest
 */
function onFailed (reject, http, xmlhttp) {
  reject({
    status: xmlhttp.status,
    response: xmlhttp.response,
    headers: xmlhttp.getAllResponseHeaders()
  })
}

/**
 * Checks if status code is in range 200&#x2026;299 to enshure response is in Ok state
 * @param {Number} statusCode - HTTP status code
 * @return {Boolean} true id status OK-like
 */
function isStatusOkLike (statusCode) {
  const delta = statusCode - 200
  const isOk = delta &gt;= 0
  return isOk &amp;&amp; delta &lt; 100
}

/**
 * Cunstructs XmlHttpRequest object
 * @param {fulfillCallback} fulfill &#x2013; fulfill callback
 * @param {rejectCallback} reject &#x2013; reject callback
 * @returns {Object} XMLHttpRequest &#x2013; XMLHttpRequest
 */
function getXmlHttp (fulfill, reject) {
  const xmlhttp = new XMLHttpRequest()
  xmlhttp.onreadystatechange = () =&gt; {
    if (xmlhttp.readyState !== 4)
      return
    if (isStatusOkLike(xmlhttp.status)) {
      fulfill(xmlhttp)
    } else {
      reject(xmlhttp)
    }
  }
  return xmlhttp
}

/**
 * Executes any submit type request
 * @param {Object} http &#x2013; HTTP object
 * @returns {Object} - Promise
 */
function submit (http) {
  return new Promise((fulfill, reject) =&gt; {
    const xmlhttp = getXmlHttp(
      onSucceed.bind(this, fulfill, http),
      onFailed.bind(this, reject, http)
    )

    let url = mixinDynamicSegmentsValues(http.url, http.dynamicSegments)
    url = addQueryParams(url, http.queryParams)

    xmlhttp.open(http.method, url, true)
    setResponseType(xmlhttp, http.responseType)
    addHeaders(xmlhttp, http.headers)
    const body = http.bodyProcessor(http.body)
    xmlhttp.send(body)
  })
}

/**
 * Executes GET request
 * @param {Object} http &#x2013; HTTP object
 * @returns {Object} - Promise
 */
function get (http) {
  return new Promise((fulfill, reject) =&gt; {
    const xmlhttp = getXmlHttp(
      onSucceed.bind(this, fulfill, http),
      onFailed.bind(this, reject, http)
    )

    let url = mixinDynamicSegmentsValues(http.url, http.dynamicSegments)
    url = addQueryParams(url, http.queryParams)

    xmlhttp.open(&apos;GET&apos;, url, true)
    addHeaders(xmlhttp, http.headers)
    setResponseType(xmlhttp, http.responseType)

    xmlhttp.send(null)
  })
}

const methodsHandlerMap = {
  GET: get,
  POST: submit,
  PUT: submit,
  DELETE: submit
}

/**
 * Executes validated http request
 * @param {Object} http &#x2013; HTTP object
 * @returns {Object} &#x2013; Promise
 */
function exec (http) {
  const handler = methodsHandlerMap[http.method]
  if (!handler)
    throw `Method ${http.method} is not supported`
  return handler(http)
}

export default exec
</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.2.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
